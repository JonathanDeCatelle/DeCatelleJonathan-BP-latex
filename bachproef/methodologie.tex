%%=============================================================================
%% Methodologie
%%=============================================================================

\chapter{Methodologie}
\label{ch:methodologie}

%% TODO: Hoe ben je te werk gegaan? Verdeel je onderzoek in grote fasen, en
%% licht in elke fase toe welke stappen je gevolgd hebt. Verantwoord waarom je
%% op deze manier te werk gegaan bent. Je moet kunnen aantonen dat je de best
%% mogelijke manier toegepast hebt om een antwoord te vinden op de
%% onderzoeksvraag.

Zoals elk onderzoek start ook dit onderzoek met een uitgebreide literatuurstudie van wat mobiele applicaties zijn, 
hoe dat ze worden ontwikkeld en welke functionaliteiten onderzocht gaan worden. Deze literatuurstudie is te vinden in Hoofdstuk \ref{ch:stand-van-zaken}.
\\\\
Vervolgens wordt er in hoofdstuk \ref{ch:ontwikkelomgeving} gekeken hoe dat we de ontwikkelomgeving opstellen om met Kotlin in Android Studio 
te werken en met React native in Visual Studio Code.
\\\\
Na het opstellen van de ontwikkelomgeving wordt er in hoofdstuk \ref{ch:projecten} uitgelegd hoe dat we de blanco projecten aanmaken. 
Deze blanco projecten worden dan doorheen de bachelorproef gebruikt om functionaliteiten uit te werken.
\\\\
Daarna zullen alle functionaliteiten uitgewerkt worden tot een project, hier wordt dan ook de ontwikkeltijd van een functionaliteit 
gedocumenteerd met daarbij eventuele bugs of problemen. Ook wordt hier de performantie van de functionaliteiten gemeten. 
En de eventuele mogelijkheid om op te schalen zal hier ook bekeken worden. Elke functionaliteit wordt opgedeeld in zijn eigen hoofdstuk. 
Op die manier kunnen de resultaten per functionaliteit duidelijk teruggevonden worden.
\begin{itemize}
    \item Hoofdstuk \ref{ch:basisfunctionaliteiten} voor de basisfunctionaliteiten
    \item Hoofdstuk \ref{ch:sensoren} voor het gebruik van sensoren
    \item Hoofdstuk \ref{ch:notificaties} voor de push-notificaties
    \item Hoofdstuk \ref{ch:audioenvideo} voor de audio- en videospelers
\end{itemize}
Tot slot worden de resultaten en individuele conclusies van alle functionaliteiten uit de vorige hoofdstukken opgelijst en samengevat 
in hoofdstuk \ref{ch:conclusie} om een antwoord te geven op de onderzoeksvragen uit hoofdstuk \ref{ch:inleiding}.

\section{Volgorde onderzoek}
Voor de functionaliteiten te onderzoeken zullen we hetzelfde stappenplan volgen per functionaliteit. 
\begin{enumerate}
    \item Blanco project aanmaken.
    \item Ontwikkeltijd meten.
    \begin{enumerate}
        \item Duurtijd van functionaliteit implementeren.
        \item Duurtijd van eventuele bugs of problemen.
    \end{enumerate}
    \item Performantie van functionaliteit meten.
    \item Mogelijkheid om op te schalen onderzoeken.
    \item resultaten formuleren.
\end{enumerate}
We zullen beginnen door een blanco project aan te maken. Daarna zullen we op dit blanco project de functionaliteit in kwestie implementeren. 
Hierbij gaan we dan de tijd nodig om de functionaliteit te implementeren meten en ook eventuele bugs of problemen. 
Na het implementeren van de functionaliteit zullen we bij beide applicaties de performantie meten. 
Daarna gaan we kijken of dat de functionaliteit opgeschaald kan worden, hoe moeilijk of makkelijk dit kan gebeuren en hoe dat dit moet gebeuren. 
Tot slot zullen we dan per functionaliteit een conclusie formuleren op basis van de verkregen resultaten.

\section{Hoe word er getest}
\subsection{Performantie}
Hoe gaan we de performantie van applicaties doorheen het onderzoek meten?

\paragraph{Android Studio}
De performantie van native applicaties kan worden gemeten met de Android profiler tool binnen Android Studio 
\textit{View > Tool Windows > Profiler}. Deze tool stelt ons in staat om de performantie van applicaties 
tijdens het uitvoeren te analyseren en meten. Het geeft ons gedetailleerde inzichten 
in verschillende prestatieaspecten, zoals CPU-gebruik, geheugengebruik, netwerkactiviteit en 
energieverbruik. Met de Android Profiler kunnen we ook realtime grafieken genereren en de gegevens bekijken. 

\paragraph{React native}
Om de performantie van de React native applicaties te meten kunnen we gebruik maken van de Performance Monitor tool. 
Deze is beschikbaar via de React native Developer Tools en is geoptimaliseerd om de werking en performantie van React native 
componenten te meten. Naast de Performance Monitor bieden de React native Developer 
Tools ook nog andere tools aan zoals: Element Inspector, Network Inspector, Console Logging en Redux Debugger. De 
Performance Monitor tool is specifiek ontworpen voor het meten en analyseren van de performantie

\paragraph{Probleem performantietools}
Normaal gezien indien je een van de twee applicaties zou testen, zou je gebruik maken van bovenstaande tools.
Maar ondanks dat de allebei inzicht geven in de performantie van een applicatie, 
zijn er een aantal verschillen tussen beide tools die het vergelijken van de applicaties moeilijk maken. 
Elke tool is namelijk zodanig ontworpen om de performantie van de individuele applicatie te meten en analyseren.
Op die manier kunnen eventuele \gls{bottlenecks} ontdekt worden binnen de applicatie om zo de performantie te verbeteren.
\\\\
Het probleem voor dit onderzoek is dat de performantie van beide applicaties met elkaar vergeleken moet worden. 
En met de specifieke performantietools is dit niet mogelijk. Daarom moeten we hiervoor kijken naar een externe 
library die deze taak op zich kan nemen. 

\subparagraph{Firebase Performance Monitoring}
Hiervoor gaan we de Firebase Performance Monitoring tool gebruiken \url{https://firebase.google.com/docs/perf-mon/}. 
Deze is onwtikkeld door Google en stelt ons in staat om de performantie van beide applicaties onafhankelijk te meten en 
vergelijken met elkaar. Dankzij deze tool kunnen we bijvoorbeeld opstarttijd, HTTP requests, schermlaadtijd, enz... meten.
De implementatie van deze library voor beide ontwikkelmethodes wordt besproken in hoofdstuk \ref{ch:projecten}.

\subsection{Schaalbaarheid}
Hoe gaan we de schaalbaarheid van applicaties doorheen het onderzoek meten?

\paragraph{Complexiteit}
Als eerst zullen we de complexiteit van de code analyseren om te beoordelen hoe goed deze zijn gestructureerd en georganiseerd.
Daarnaast zullen we ook kijken of dat de functionaliteit ik kleine herbruikbare componenten opgedeeld kan worden. Aangezien een 
goed gestructureerde codebase dat opgedeeld is in kleine componenten gemakkelijk uitgebreid en aangepast kan worden.

\paragraph{Herbruikbaarheid}
Tot slot zullen we ook kijken in hoever dat de code van de functionaliteiten hergebruikt kan worden in andere 
delen van de applicatie. Want als componenten gemakkelijk hergebruikt kunnen worden, dan vergroot dit de schaalbaarheid 
van de applicatie, omdat toekomstige aanpassingen of uitbreidingen makkelijk geïmplementeerd kunnen worden.

\subsection{Ontwikkeltijd}
Hoe gaan we de ontwikkeltijd van applicaties doorheen het onderzoek meten?

\paragraph{Algemene ontwikkeltijd}
Om de algemene ontwikkeltijd van een functionaliteit te meten zullen we nauwkeurig bijhouden hoeveel tijd er wordt 
besteed aan het implementeren. Dit kan dan verder opgedeeld worden in de opzet en implementatie van een functionaliteit. 
Daarnaast zullen we ook de compiletijd van applicaties vergelijken. Aangezien dit een enorm verschil kan hebben op de 
ontwikkeltijd bij een applicatie. Indien een ontwikkelaar altijd vijf minuten moet wachten om veranderingen in de applicatie 
te zien in vergelijking met twee minuten, dan zal dit de algemene ontwikkeltijd veel beïnvloeden.

\paragraph{Bugs}
Indien er eventuele bugs voorkomen tijdens het implementeren van een functionaliteit, dan zal deze ook beschreven worden. 
Wat is de oorzaak, hoe is het opgelost en hoeveel tijd is er hier aan gespendeerd. Bij het vormen van een conclusie zal er ook 
rekening worden gehouden met eventuele bugs die optraden tijdens het implementeren.