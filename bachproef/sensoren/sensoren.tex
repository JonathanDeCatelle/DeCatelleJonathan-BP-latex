%%=============================================================================
%% Gebruik van sensoren
%%=============================================================================

\chapter{Gebruik van sensoren}%
\label{ch:sensoren}

In dit hoofdstuk wordt het gebruik van sensoren bij native en cross-platform vergeleken met elkaar. 
Met de resultaten kan dan een gepaste conclusie worden gevormd.

\section{Native}
\subsubsection{Wat is er nodig}
Om toegang te krijgen tot de sensoren bij native ontwikkeling moeten er geen extra libraries of tools worden gebruikt.
Android studio biedt een aantal klassen aan die gebruikt kunnen worden: SensorManager, 
SensorEventListener en SensorEvent. Dankzij deze klassen kan de data van sensoren zoals accelerometer en 
gyroscoop worden opgevraagd.

\subsubsection{Uitvoering}

\input{./sensoren/sensorennativeuitvoering.tex}

\subsubsection{Ontwikkeltijd}

\input{./sensoren/sensorennativeontwikkeltijd.tex}

\subsubsection{Performantie}

\input{./sensoren/sensorennativeperformantie.tex}

\subsubsection{Schaalbaarheid}

\input{./sensoren/sensorennativeschaalbaarheid.tex}


\section{Cross-platform}
\subsubsection{Wat is er nodig}
Om bij React Native toegang te krijgen tot de sensoren moet er gebruik worden gemaakt van de react-native-sensors library.
Deze library biedt onder andere toegang tot de accelerometer en gyroscoop. Het is een wrapper voor de
native sensoren van Android en iOS. 

\subsubsection{Uitvoering}

\input{./sensoren/sensorencrossuitvoering.tex}

\subsubsection{Ontwikkeltijd}

\input{./sensoren/sensorencrossontwikkeltijd.tex}

\subsubsection{Performantie}

\input{./sensoren/sensorencrossperformantie.tex}

\subsubsection{Schaalbaarheid}

\input{./sensoren/sensorencrossschaalbaarheid.tex}


\section{Conclusie}
De tijdsduur van het ophalen van de data van de sensoren is bij native veel sneller dan bij cross-platform.
Dit komt omdat de library die gebruikt wordt bij cross-platform een wrapper is voor de native sensoren.
Hierdoor moet de data van de sensoren eerst naar de wrapper gestuurd worden en pas daarna naar de applicatie.
Bij native is dit niet het geval: de data van de sensoren wordt rechtstreeks naar de applicatie gestuurd.
Het ophalen van data is daardoor gemiddeld 10ms trager bij cross-platform dan bij native.
\\\\
Bij het geheugengebruik is er geen verschil tijdens het ophalen van sensoren data en evenmin wanneer er 
niks gebeurt in de applicatie. Ondanks het feit dat het ophalen van data niet beïnvloed 
wordt, wordt er 121.59\% meer geheugen gebruikt bij React Native dan 
bij Android (88MB in vergelijking met gemiddeld 195MB). Dit komt omdat cross-platform een extra 
library moet implementeren. Deze library neemt ook geheugen in beslag.
\\\\
Bij het CPU gebruik zijn er onderling tussen de accelerometer en gyroscoop ook verschillen. Bij native 
heeft de accelerometer geen piek maar blijft deze constant op gemiddeld 23\% CPU gebruik. Bij cross-platform heeft
de accelerometer een piek van 50\% CPU gebruik waarna deze naar 9\% zakt, een groot verschil. 
De gyroscoop heeft bij native een piek 30\% CPU gebruik waarna deze naar 8\% zakt. Bij cross-platform
is de piek 40\% CPU gebruik waarna deze naar 10\% zakt. Daarnaast is er bij alle sensoren een schommeling van 5 tot 20\%. 
Dit komt omdat de sensoren data constant wordt opgehaald. Normaal zou er verwacht worden dat de sensoren bij native 
minder CPU gebruiken, aangezien de data eerst naar de wrapper wordt gestuurd en pas daarna naar de applicatie. Maar bij 
de accelerometer is dit niet het geval. Hier is het CPU gebruik bij cross-platform lager dan bij native.
\\\\
\begin{tabular}{ |p{3cm}||p{5cm}|p{5cm}| }
    \hline
    \multicolumn{3}{|c|}{Accelerometer} \\ 
    \hline
     & Native (Android) & Cross-platform (React Native) \\
    \hline
     & \multicolumn{2}{|c|}{Tijdsduur} \\
    \hline
    Minimaal & 736µs & 310µs \\
    Maximaal & 7ms & 143ms \\
    Gemiddeld & 2ms & 12ms \\
    \hline
     & \multicolumn{2}{|c|}{Geheugen} \\ 
    \hline
    Offset & 2-3MB & 3-4MB \\
    Gemiddeld & 88MB & 192MB \\
    \hline
     & \multicolumn{2}{|c|}{CPU} \\
    \hline
    (Begin)Piek & / & 50\% \\
    Offset & 20\% & 10\% \\
    Gemiddeld & 23\% & 9\% \\
    \hline
\end{tabular}
\\\\
\begin{tabular}{ |p{3cm}||p{5cm}|p{5cm}| }
    \hline
    \multicolumn{3}{|c|}{Gyroscoop} \\ 
    \hline
     & Native (Android) & Cross-platform (React Native) \\
    \hline
     & \multicolumn{2}{|c|}{Tijdsduur} \\
    \hline
    Minimaal & 996µs & 203µs \\
    Maximaal & 3ms & 163ms \\
    Gemiddeld & 2ms & 11ms \\
    \hline
     & \multicolumn{2}{|c|}{Geheugen} \\ 
    \hline
    Offset & 4-5MB & 3-4MB \\
    Gemiddeld & 88MB & 197MB \\
    \hline
     & \multicolumn{2}{|c|}{CPU} \\
    \hline
    (Begin)Piek & 30\% & 40\% \\
    Offset & 5\% & 10\% \\
    Gemiddeld & 8\% & 10\% \\
    \hline
\end{tabular}
\\\\
De ontwikkeltijd voor het implementeren van sensoren
bij native en cross-platform is ongeveer hetzelfde. Buiten het feit dat cross-platform een extra library moet
implementeren waardoor de ontwikkeltijd iets langer wordt. 
\\\\
Op vlak van schaalbaarheid is er geen verschil tussen native en cross-platform. Beide applicaties kunnen
gemakkelijk uitgebreid worden met extra sensoren en de bestaande logica van de sensoren kan gemakkelijk 
hergebruikt of opgeschaald worden.
\\\\
Uit deze resultaten kan geconcludeerd worden dat applicaties die intensief gebruik maken van de sensoren 
beter native gebruiken aangezien deze sneller gegevens kan ophalen. Daarnaast is cross-platform beter in gebruik 
voor eenvoudige applicaties die de sensoren niet intensief gebruiken.














